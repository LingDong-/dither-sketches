include "std/g3d"
include "std/list"
include "std/win"
include "std/frag"
include "std/math"
include "std/io"
include "std/vec"
include "std/arr"


W := 640
H := 480
context := win.init(W,H,win.CONTEXT_3D)
g3d.init(context);
frag.init(context);

func normal_material(@varying normal:vec[f32,3]):vec[f32,4]{
  c := normal*0.5+0.5;
  return {c.x,c.y,c.z,1.0};
}
shader0 := frag.program(embed normal_material as "fragment");

func make_icosphere(order:i32):g3d.Mesh{
  PHI := 1.618034 
  verts := list[vec[f32,3]]{
    {-1,  PHI, 0}, { 1,  PHI, 0}, {-1, -PHI, 0}, { 1, -PHI, 0},
    {0, -1,  PHI}, {0,  1,  PHI}, {0, -1, -PHI}, {0,  1, -PHI},
    { PHI, 0, -1}, { PHI, 0,  1}, {-PHI, 0, -1}, {-PHI, 0,  1}
  };
  faces := list[i32]{
    0,5,11,  0, 1, 5,  0, 7, 1,  0,10,7,  0,11,10,
    1,9, 5,  5, 4,11, 11, 2,10, 10, 6,7,  7, 8, 1,
    3,4, 9,  3, 2, 4,  3, 6, 2,  3, 8,6,  3, 9, 8,
    4,5, 9,  2,11, 4,  6,10, 2,  8, 7,6,  9, 1, 8
  }
  
  mid_pts := dict[vec[i32,2],i32]{}
  func add_mid_pt(ii:vec[i32,2]):i32{
    if (ii.x > ii.y){
      ii = ii.yx;
    }
    if (mid_pts[ii]){
      return mid_pts[ii]-1;
    }
    verts.push((verts[ii.x]+verts[ii.y])*0.5);
    mid_pts[ii] = verts.length();
    return mid_pts[ii]-1;
  }
  for (iter:=0;iter<order;iter++){
    n := faces.length();
    for (i:=0; i<n;i+=3){
      a := faces[i];
      b := faces[i+1];
      c := faces[i+2];
      d := add_mid_pt({a,b});
      e := add_mid_pt({b,c});
      f := add_mid_pt({c,a});
      faces.push(b); faces.push(e); faces.push(d);
      faces.push(c); faces.push(f); faces.push(e);
      faces.push(d); faces.push(e); faces.push(f);
      faces[i+1] = d;
      faces[i+2] = f;
    }
  }
  normals := list[vec[f32,3]]{};
  uvs := list[vec[f32,2]]{};
  for (i := 0; i < verts.length(); i++){
    verts[i] = verts[i].dir();
    normals.push(verts[i]);
    ofs := verts[i]*0.75+1.0;
  }
  return g3d.Mesh{vertices:verts, indices:faces, normals:normals};
};


func make_wireframe(mesh:g3d.Mesh):g3d.Mesh{
  verts := list[vec[f32,3]]{}
  edges := dict[vec[i32,2],i32]{}

  func add_edge(ii:vec[i32,2]){
    if (ii.x > ii.y){
      ii = ii.yx;
    }
    if (edges[ii]){
      return;
    }
    verts.push(mesh.vertices[ii.x]);
    verts.push(mesh.vertices[ii.y]);
    edges[ii] = 1;
  }
  for (i := 0; i < mesh.indices.length(); i+=3){
    a := mesh.indices[i];
    b := mesh.indices[i+1];
    c := mesh.indices[i+2];
    add_edge({a,b});
    add_edge({b,c});
    add_edge({c,a});
  }

  return g3d.Mesh{mode:g3d.MODE_LINE_LIST,vertices:verts}
}


ico := make_icosphere(2);
wir := make_wireframe(ico);

cam := g3d.Camera{}
cam.perspective(60,W/(H as f32),0.1,100.0);

frame := 0;
while (1){
  model := g3d.mat.rotate_deg(g3d.AXIS_X,frame*0.02)@*g3d.mat.rotate_deg(g3d.AXIS_Y,frame*0.01);

  g3d.background(0.2)

  cam.look_at({0,0,3},{0,0,0},g3d.AXIS_Y);
  frag.begin(shader0);
  cam.begin();
  ico.draw(model)
  cam.end();
  frag.end();

  cam.look_at({0,0,2.99},{0,0,0},g3d.AXIS_Y);
  cam.begin();
  wir.draw(model)
  cam.end();

  g3d.flush();
  win.poll();
  frame++;
}