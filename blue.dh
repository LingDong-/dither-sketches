include "std/arr"
include "std/rand"
include "std/math"
include "std/drw"
include "std/io"

M := 32;
N := 0;
BP := arr.make[i32]({M,M},0);
CP := arr.make[i32]({M,M},0);
DA := arr.make[f32]({M,M},0.0);
DH := arr.make[i32]({M,M},-1);

for (i := 0; i < M; i++){
  for (j := 0; j < M; j++){
    BP[i,j] = rand.random()<0.1;
  }
}

func filt(x:f32,y:f32):f32{
  return math.exp(-(x*x+y*y)/4.5);
}

func compute_da(){
  for (y := 0; y < M; y++){
    for (x := 0; x < M; x++){
      d := 0.0;
      for (q := -M/2; q < M/2; q++){
        for (p := -M/2; p < M/2; p++){
          d += BP[(y-q+M)%M,(x-p+M)%M] * filt(p,q);
        }
      }
      DA[y,x] = d;
    }
  }
}
func extrema_da():vec[i32,4]{
  lv := math.INF;
  li := -1;
  lj := -1;
  rv := -math.INF;
  ri := -1;
  rj := -1;
  for (i := 0; i < M; i++){
    for (j := 0; j < M; j++){
      if (!BP[i,j] && DA[i,j] < lv){
        lv = DA[i,j];
        li = i;
        lj = j;
      }
      if (BP[i,j] && DA[i,j] > rv){
        rv = DA[i,j];
        ri = i;
        rj = j;
      }
    }
  }
  return {li,lj,ri,rj};
}

func count_da():i32{
  cnt := 0;
  for (i := 0; i < M; i++){
    for (j := 0; j < M; j++){
      if (BP[i,j]){
        cnt++;
      }
    }
  }
  return cnt;
}


phase := 0;
drw.size(M*16,M*16);

while (1){

  for (i : = 0; i < M; i++){
    for (j := 0; j < M; j++){
      drw.stroke(0,0,1);
      drw.fill(DA[i,j]*0.3,BP[i,j],0);
      drw.rect(j*16,i*16,16,16);
      if (DH[i,j] >= 0){
        drw.fill(0.5,0.5,1);
        drw.text(DH[i,j],j*16,i*16+16);
      }
    }
  }

  if (phase == 0){
    compute_da();
    ({minia,minja,maxia,maxja}) := extrema_da();
    BP[maxia,maxja] = 0;
    compute_da();
    ({minib,minjb,maxib,maxjb}) := extrema_da();
    if (maxia == minib && maxja == minjb){
      for (i := 0; i < M; i++){
        for (j : = 0; j < M; j++){
          CP[i,j] = BP[i,j];
        }
      }
      N = count_da();
      phase = 1;
    }else{
      BP[minib,minjb] = 1;
    }
  }else if (phase == 1){
    compute_da();
    ({mini,minj,maxi,maxj}) := extrema_da();
    BP[maxi,maxj] = 0;
    DH[maxi,maxj] = N;
    N--;
    if (N == 0){
      for (i := 0; i < M; i++){
        for (j : = 0; j < M; j++){
          BP[i,j] = CP[i,j];
        }
      }
      N = count_da();
      phase = 2;
    }
  }else if (phase == 2){
    compute_da();
    ({mini,minj,maxi,maxj}) := extrema_da();
    BP[mini,minj] = 1;
    DH[mini,minj] = N;
    N++;
    if (N == (M * M) / 2){
      for (i := 0; i < M; i++){
        for (j : = 0; j < M; j++){
          BP[i,j] = 1-BP[i,j];
        }
      }
      N = count_da();
      phase = 3;
    }
  }else if (phase == 3){
    compute_da();
    ({mini,minj,maxi,maxj}) := extrema_da();
    BP[maxi,maxj] = 0;
    DH[maxi,maxj] = N;
    N++;
    if (N == M*M){
      phase = 4;
      for (i := 0; i < M; i++){
        for (j := 0; j < M; j++){
          if (j){
            io.print(",");
          }
          io.print(DH[i,j]);
        }
        io.println(";")
      }
    }
  }
  drw.poll();
}
