include "std/io"
include "std/str"
include "std/list"
include "std/arr"
include "std/vec"
include "std/dict"
include "std/math"
include "std/frag"
include "std/rdr"
include "std/win"
include "std/time"

typedef Piece = {
  mesh: rdr.Mesh;
  trfm: vec[f32,4,4] = rdr.mat.id;
  matl: i32 = 0;
}

W := 800
H := 600

context := win.init(W,H,win.CONTEXT_3D);
frag.init(context);
rdr.init(context);

func add_face(mesh:rdr.Mesh,face:list[vec[f32,3]]){
  for (i := 1; i < face.length()-1; i++){
    a := face[0];
    b := face[i];
    c := face[i+1];
    mesh.vertices.push(a);
    mesh.vertices.push(b);
    mesh.vertices.push(c);
    nml := (b-a).cross(c-b).dir();
    mesh.normals.push(nml);
    mesh.normals.push(nml);
    mesh.normals.push(nml);
  }
}
func add_backface(mesh:rdr.Mesh,face:list[vec[f32,3]],dep:vec[f32,3]){
  for (i := 1; i < face.length()-1; i++){
    a := face[0]+dep;
    b := face[i]+dep;
    c := face[i+1]+dep;
    mesh.vertices.push(a);
    mesh.vertices.push(c);
    mesh.vertices.push(b);
    nml := (c-b).cross(b-a).dir();
    mesh.normals.push(nml);
    mesh.normals.push(nml);
    mesh.normals.push(nml);
  }
}
func add_extrusion(mesh:rdr.Mesh,face:list[vec[f32,3]],dep:vec[f32,3]){
  for (i := 0; i < face.length(); i++){
    a := face[(i+1)%face.length()];
    b := face[i];
    c := a + dep;
    d := b + dep;
    mesh.vertices.push(a);
    mesh.vertices.push(c);
    mesh.vertices.push(b);
    mesh.vertices.push(b);
    mesh.vertices.push(c);
    mesh.vertices.push(d);
    nml := (b-a).cross(c-b).dir();
    for (j:=0;j<6;j++){
      mesh.normals.push(nml);
    }
  }
}
func add_tube(mesh:rdr.Mesh,faces:list[list[vec[f32,3]]]){
  for (i := 0; i < faces.length()-1; i++){
    for (j := 0; j < faces[i].length(); j++){
      j1 := (j+1)%faces[i].length();
      a := faces[i][j];
      b := faces[i][j1];
      c := faces[i+1][j];
      d := faces[i+1][j1];
      mesh.vertices.push(a);
      mesh.vertices.push(b);
      mesh.vertices.push(c);
      mesh.vertices.push(b);
      mesh.vertices.push(d);
      mesh.vertices.push(c);
      nml := (c-b).cross(b-a).dir();
      for (k:=0;k<6;k++){
        mesh.normals.push(nml);
      }
    }
  }
}
func add_vase(mesh:rdr.Mesh,prof:list[vec[f32,3]],n:i32,phase:f32){
  faces := list[list[vec[f32,3]]]{};
  for (i := 0; i < prof.length(); i++){
    f := list[vec[f32,3]]{};
    faces.push(f);
  }
  for (i := 0; i < n; i++){
    a := i/(n as f32) * 360.0 + phase;
    m := rdr.mat.rotate_deg(rdr.AXIS_Y,a);
    for (j := 0; j < prof.length(); j++){
      v := (m @* {...prof[j],1.}).xyzw;
      faces[j].push(v.xyz/v.w);
    }
  }
  add_tube(mesh,faces);
}

func arch1():rdr.Mesh{
  mesh := rdr.Mesh{};
  f0 := list[vec[f32,3]]{};
  f0.push({10,15.,2.0});
  f0.push({0.,15.,2.0});
  n := 10;
  for (i := 0; i < n; i++){
    a0 := (i as f32)/(n-1) * math.PI/2;
    a0 = math.PI/2-a0;
    f0.push({
      8*math.cos(a0),
      8*math.sin(a0),
      2.0
    });
  }
  f0.push({10,0.,2.0});
  add_face(mesh,f0);
  add_extrusion(mesh,f0,{0.,0.,-4.});
  add_backface(mesh,f0,{0.,0.,-4.});
  return mesh;
}

func arch1_edge():rdr.Mesh{
  mesh := rdr.Mesh{};
  ff := list[list[vec[f32,3]]]{}
  f0 := list[vec[f32,3]]{
    {10.5,0.,0.},
    {10.0,0.,2.5},{9.5,0.,2.5},{8.5,0.,2.1},{7.5,0.,2.1},
    // {7.5,0.,-2.0},{8.5,0.,-2.0},{9.5,0.,-2.5},{10.0,0.,-2.5}
    {7.5,0.,-2.1},{10.0,0.,-2.5}
  };
  n := 10;
  for (i:=0; i < n; i++){
    a0 := i/((n-1) as f32) * 180.0;
    fi := list[vec[f32,3]]{};
    mat := rdr.mat.rotate_deg(rdr.AXIS_Z, a0);
    for (j:=0; j<f0.length(); j++){
      v := (mat @* {...f0[j],1.}).xyzw;
      fi.push(v.xyz/v.w);
    }
    ff.push(fi);
  }
  add_tube(mesh,ff);
  return mesh;
}

func ceil1():rdr.Mesh{
  mesh := rdr.Mesh{};
  ff := list[list[vec[f32,3]]]{};
  n := 10;
  for (i := 0; i < n; i++){
    a := i/((n-1) as f32) * math.PI/2;
    fi := list[vec[f32,3]]{
      {8.25*math.cos(a),8.25*math.sin(a),-1.5},
      {8.25*math.cos(a),8.25*math.sin(a),-10.75+8.25*math.cos(a)},
      {10.0,8.25*math.sin(a),-10.75+8.25*math.cos(a)},
    }
    ff.push(fi);
  }
  add_tube(mesh,ff);
  return mesh;
}

func ceil1_corner():rdr.Mesh{
  mesh := rdr.Mesh{};
  ff := list[list[vec[f32,3]]]{};
  n := 10;
  for (i := 0; i < n; i++){
    a := i/((n-1) as f32) * math.PI/2;
    fi := list[vec[f32,3]]{
      {-0.75+8.25*math.cos(a),8.25*math.sin(a),-0.0},
      {-0.75+8.25*math.cos(a),8.25*math.sin(a),-10.75+8.25*math.cos(a)},
      {10.0,8.25*math.sin(a),-10.75+8.25*math.cos(a)},
    }
    ff.push(fi);
  }
  add_tube(mesh,ff);
  return mesh;
}

func col1_cap():rdr.Mesh{
  mesh := rdr.Mesh{};
  prof := list[vec[f32,3]]{
    {1.,0.,1.},
    {3.,0.,3.},
    {3.,-0.5,3.},
    {2.75,-0.5,2.75},
    {2.75,-0.75,2.75},
    {3.,-0.75,3.},
    {3.,-1.5,3.},
    {2.75,-2.,2.75},
    {1.75,-2.75,1.75},
    {1.,-2.75,1.},
  }
  add_vase(mesh,prof,4,0.);
  return mesh;
}

func col1():rdr.Mesh{
  mesh := rdr.Mesh{};
  prof := list[vec[f32,3]]{
    {2.0,0.,0.},
    {2.0,-0.5,0.},
    {2.25,-1.0,0.},
    {2.0,-1.25,0.},
    {2.25,-1.5,0.},
    {2.,-1.75,0.},
    {2.,-12.,0.},
  }
  add_vase(mesh,prof,8,22.5);
  return mesh;
}

func arch2(w:f32):rdr.Mesh{
  mesh := rdr.Mesh{};
  f0 := list[vec[f32,3]]{};
  f0.push({w,15.,2});
  f0.push({0.,15.,2});
  r := 8.;
  n := 11;
  for (i := 0; i < n; i++){
    a0 := (i as f32)/(n-1) * math.PI/3;
    a0 = math.PI/3-a0;
    f0.push({
      4-r+r*math.cos(a0),
      r*math.sin(a0)*0.8,
      2.
    });
  }
  f0.push({w,0.,2});
  add_face(mesh,f0);
  add_extrusion(mesh,f0,{0.,0.,-4.});
  add_backface(mesh,f0,{0.,0.,-4.});
  return mesh;
}

func arch2_edge():rdr.Mesh{
  mesh := rdr.Mesh{};
  ff := list[list[vec[f32,3]]]{}
  f0 := list[vec[f32,3]]{
    {1.0,0.,0.},
    {0.5,0.,2.5},{0.0,0.,2.5},{-0.5,0.,2.1},{-1.0,0.,2.1},
    {-1.0,0.,-2.1},{0.0,0.,-2.5}
  };
  n := 11;
  r := 8;
  for (i:=0; i < n; i++){
    a0 := i/((n-1) as f32) * 180.0;
    fi := list[vec[f32,3]]{};
    mat0 := rdr.mat.rotate_deg(rdr.AXIS_Z, a0);
    mat1 : vec[f32,4,4];

    if (i <= (n-1)/2){
      a1 := (i as f32)/((n-1)/2) * math.PI/3;
      mat1 = rdr.mat.translate(4-r+r*math.cos(a1),r*math.sin(a1)*0.8,0);
    }else{
      a1 := ((i-(n-1)/2) as f32)/((n-1)/2) * math.PI/3 + math.PI*2/3;
      mat1 = rdr.mat.translate(r-4+r*math.cos(a1),r*math.sin(a1)*0.8,0);
    }
    for (j:=0; j<f0.length(); j++){
      v := (mat1 @* mat0 @* {...f0[j],1.}).xyzw;
      fi.push(v.xyz/v.w);
    }
    ff.push(fi);
  }
  add_tube(mesh,ff);
  return mesh;
}

func col2():rdr.Mesh{
  mesh := rdr.Mesh{};
  prof := list[vec[f32,3]]{
    {1,0,0.},
    {2.5,0,0.},
    {2.75,-0.25,0.},
    {2.5,-0.5,0.},
    {2.5,-1.0,0.},
    {1.5,-2.5,0.},
    {1.75,-2.75,0.},
    {1.5,-3.0,0.},
    {1.5,-11.0,0.},
    {2.0,-11.5,0.},
    {2.0,-12,0.},
  }
  for (i := 0; i < prof.length(); i++) prof[i] = prof[i].xyx;
  add_vase(mesh,prof,4,0.);
  return mesh;
}

func col3_cap():rdr.Mesh{
  mesh := rdr.Mesh{};
  f0 := list[vec[f32,3]]{
    {-2.0,0,2.5},{2,0,2.5},{2.0,0,-2.5},{-2.0,0,-2.5}
  }
  add_face(mesh,f0);
  add_extrusion(mesh,f0,{0.,-0.5,0});
  add_backface(mesh,f0,{0.,-0.5,0});
  f1 := list[vec[f32,3]]{
    {0.,-0.5,0.25},{0.0,-2.0,0.25},{1.0,-2.0,0.25},
    {1.25,-1.75,0.25}, {1.5,-1.75,0.25}, {1.75,-1.5,0.25}, {1.75,-1.25,0.25},
    {2.0,-1.0,0.25},{2.0,-0.5,0.25}
  }
  for (i := 0; i < 4; i++){
    fi := list[vec[f32,3]]{};
    a := i*360/4.0;
    mat := rdr.mat.rotate_deg(rdr.AXIS_Y, a);
    for (j := 0; j < f1.length(); j++){
      v := (mat @* {...f1[j],1.}).xyzw;
      fi.push(v.xyz/v.w);
    }
    extw := (mat @* {0.,0,-0.5,1.0}).xyzw;
    ext := extw.xyz/extw.w;
    add_face(mesh,fi);
    add_extrusion(mesh,fi,ext);
    add_backface(mesh,fi,ext);
  }
  prof := list[vec[f32,3]]{
    {0.25,-11.0,0.},
    {1.25,-11.0,0.},
    {1.75,-11.5,0.},
    {2.0,-11.5,0.},
    {2.0,-12,0.},
  }
  for (i := 0; i < prof.length(); i++) prof[i] = prof[i].xyx;
  add_vase(mesh,prof,4,0.);
  return mesh;
}

func col3():rdr.Mesh{
  mesh := rdr.Mesh{};
  prof := list[vec[f32,3]]{
    {1.25,0,0.},
    {1.25,-0.5,0.},
    {0.8,-1.0,0.},
    {0.6,-1.5,0.},
    {0.8,-1.5,0.},
    {0.8,-1.75,0.},
    {0.6,-1.75,0.},
    {0.65,-3.0,0.},
    {1.0,-7.5,0.},
    {1.0,-8.5,0.},
    {0.85,-9.5,0.},
    {0.55,-10.0,0.},
    {0.75,-10.25,0.},
    {0.85,-10.5,0.},
  }
  for (i := 0; i < prof.length(); i++) prof[i] = prof[i].xyx;
  add_vase(mesh,prof,14,0.);
  return mesh;
}


func arch3a():rdr.Mesh{
  mesh := rdr.Mesh{};
  f0 := list[vec[f32,3]]{};
  f0.push({10,10.,2.0});
  f0.push({0,10.,2.0});
  f0.push({0,4.,2.0});
  f0.push({2.,4.,2.0});
  f0.push({2.,0.,2.0});
  f0.push({10,0.,2.0});
  add_face(mesh,f0);
  add_extrusion(mesh,f0,{0.,0.,-4.});
  add_backface(mesh,f0,{0.,0.,-4.});

  f1 := list[vec[f32,3]]{};
  f1.push({0,20.,2.0});
  f1.push({0,15.,2.0});
  n := 5;
  for (i := 0; i < n; i++){
    a0 := math.PI*1.0 - (i as f32)/(n-1) * math.PI*0.5;
    f1.push({
      10+2*math.cos(a0),
      15+2*math.sin(a0),
      2.0
    });
  }
  f1.push({10,20.,2.0});
  add_face(mesh,f1);
  add_extrusion(mesh,f1,{0.,0.,-4.});
  add_backface(mesh,f1,{0.,0.,-4.});

  f2 := list[vec[f32,3]]{};
  f2.push({0,10.,2.0});
  f2.push({10,10.,2.0});
  for (i := 0; i < n; i++){
    a0 := math.PI*1.5 - (i as f32)/(n-1) * math.PI*0.5;
    f2.push({
      10+2*math.cos(a0),
      15+2*math.sin(a0),
      2.0
    });
  }
  f2.push({0,15.,2.0});
  add_face(mesh,f2);
  add_extrusion(mesh,f2,{0.,0.,-4.});
  add_backface(mesh,f2,{0.,0.,-4.});
  return mesh;
}

func arch3b():rdr.Mesh{
  mesh := rdr.Mesh{};
  f0 := list[vec[f32,3]]{};
  f0.push({10,20.,2.0});
  f0.push({0,20.,2.0});
  f0.push({0,4.,2.0});
  f0.push({2.,4.,2.0});
  f0.push({2.,0.,2.0});
  f0.push({10,0.,2.0});
  add_face(mesh,f0);
  add_extrusion(mesh,f0,{0.,0.,-4.});
  add_backface(mesh,f0,{0.,0.,-4.});
  return mesh;
}

func arch3_edge1():rdr.Mesh{
  mesh := rdr.Mesh{};
  ff := list[list[vec[f32,3]]]{}
  f0 := list[vec[f32,3]]{
    {1.0,0.,0.},
    {0.5,0.,2.5},{0.0,0.,2.5},{-0.5,0.,2.1},{-1.0,0.,2.1},
    {-1.0,0.,-2.1},{0.0,0.,-2.5}
  };

  mat1 := rdr.mat.translate(2.,0,0);
  mat2 := rdr.mat.translate(2.,4,0) @* rdr.mat.rotate_deg(rdr.AXIS_Z, 45) @* rdr.mat.scale(1.414,1.,1.);
  mat3 := rdr.mat.translate(-2.,4,0) @* rdr.mat.rotate_deg(rdr.AXIS_Z, 135) @* rdr.mat.scale(1.414,1.,1.);
  mat4 := rdr.mat.translate(-2.,0,0) @* rdr.mat.rotate_deg(rdr.AXIS_Z, 180);

  f1 := list[vec[f32,3]]{};
  for (j:=0; j<f0.length(); j++){
    v := (mat1 @* {...f0[j],1.}).xyzw;
    f1.push(v.xyz/v.w);
  }
  f2 := list[vec[f32,3]]{};
  for (j:=0; j<f0.length(); j++){
    v := (mat2 @* {...f0[j],1.}).xyzw;
    f2.push(v.xyz/v.w);
  }
  f3 := list[vec[f32,3]]{};
  for (j:=0; j<f0.length(); j++){
    v := (mat3 @* {...f0[j],1.}).xyzw;
    f3.push(v.xyz/v.w);
  }
  f4 := list[vec[f32,3]]{};
  for (j:=0; j<f0.length(); j++){
    v := (mat4 @* {...f0[j],1.}).xyzw;
    f4.push(v.xyz/v.w);
  }

  ff.push(f1);
  ff.push(f2);
  ff.push(f3);
  ff.push(f4);
  
  add_tube(mesh,ff);
  return mesh;
}

func arch3_ledge():rdr.Mesh{
  mesh := rdr.Mesh{};
  f0 := list[vec[f32,3]]{
    {10.0,0,3.5},
    {10.0,-0.5,3.5},
    {10.0,-1.0,3},
    {10.0,-1.0,-3},
    {10.0,0.0,-3}
  }
  add_face(mesh,f0);
  add_extrusion(mesh,f0,{-20.,0,0});
  add_backface(mesh,f0,{-20.,0,0});
  return mesh;
}

func arch3_edge2():rdr.Mesh{
  mesh := rdr.Mesh{};
  ff := list[list[vec[f32,3]]]{}
  f0 := list[vec[f32,3]]{
    {0.75,0.,0.},
    {0.5,0.,2.5},{0.25,0.,2.5},{0.0,0.,2.1},{-0.5,0.,2.1},
    {-0.5,0.,-2.1},{0.0,0.,-2.5}
  };
  n := 14;
  for (i:=0; i < n; i++){
    a0 := i/((n-1) as f32) * 360;
    fi := list[vec[f32,3]]{};
    mat := rdr.mat.rotate_deg(rdr.AXIS_Z, a0) @* rdr.mat.translate(2,0,0);
    for (j:=0; j<f0.length(); j++){
      v := (mat @* {...f0[j],1.}).xyzw;
      fi.push(v.xyz/v.w);
    }
    ff.push(fi);
  }
  add_tube(mesh,ff);

  f1 := list[vec[f32,3]]{
    {2.,2,1.5},
    {0.,2,1.5},
    {0.,1.5,1.5},
    {0.5,1.0,1.5},
    {0.5,0.5,1.5},
    {1.0,0.5,1.5},
    {1.5,0.0,1.5},
    {2.,0,1.5},
  };
  for (i := 0; i < 4; i++){
    fi := list[vec[f32,3]]{};
    a := i*360/4.0;
    mat := rdr.mat.rotate_deg(rdr.AXIS_Z, a);
    for (j := 0; j < f1.length(); j++){
      v := (mat @* {...f1[j],1.}).xyzw;
      fi.push(v.xyz/v.w);
    }
    extw := (mat @* {0.,0,-1.0,1.0}).xyzw;
    ext := extw.xyz/extw.w;
    add_face(mesh,fi);
    add_extrusion(mesh,fi,ext);
    add_backface(mesh,fi,ext);
  }
  return mesh;
}

func roof1(m:i32,n:i32):rdr.Mesh{
  mesh := rdr.Mesh{};
  ff := list[list[vec[f32,3]]]{}
  f0 := list[vec[f32,3]]{
    {0,0,33.5},{0,1,33.5},{0,10,0},{0,0,0},
  };
  scl := rdr.mat.scale(1.414,1.,1.);;
  mat1 := rdr.mat.translate(0,0,0) @* rdr.mat.rotate_deg(rdr.AXIS_Y, 45) @* scl;
  mat2 := rdr.mat.translate((n+2)*20,0,0) @* rdr.mat.rotate_deg(rdr.AXIS_Y, -45) @* scl;
  mat3 := rdr.mat.translate((n+2)*20,0,(m+2)*20) @* rdr.mat.rotate_deg(rdr.AXIS_Y, -135) @* scl;
  mat4 := rdr.mat.translate(0.,0,(m+2)*20) @* rdr.mat.rotate_deg(rdr.AXIS_Y, -225) @* scl;

  f1 := list[vec[f32,3]]{};
  for (j:=0; j<f0.length(); j++){
    v := (mat1 @* {...f0[j],1.}).xyzw;
    f1.push(v.xyz/v.w);
  }
  f2 := list[vec[f32,3]]{};
  for (j:=0; j<f0.length(); j++){
    v := (mat2 @* {...f0[j],1.}).xyzw;
    f2.push(v.xyz/v.w);
  }
  f3 := list[vec[f32,3]]{};
  for (j:=0; j<f0.length(); j++){
    v := (mat3 @* {...f0[j],1.}).xyzw;
    f3.push(v.xyz/v.w);
  }
  f4 := list[vec[f32,3]]{};
  for (j:=0; j<f0.length(); j++){
    v := (mat4 @* {...f0[j],1.}).xyzw;
    f4.push(v.xyz/v.w);
  }

  ff.push(f1);
  ff.push(f2);
  ff.push(f3);
  ff.push(f4);
  ff.push(f1);
  
  add_tube(mesh,ff);
  return mesh;
}

func arch1_corner():rdr.Mesh{
  mesh := rdr.Mesh{};
  f0 := list[vec[f32,3]]{
    {-2,0,-2},{-2,15,-2},{0,15,-2},{0,0,-2}
  }
  f1 := list[vec[f32,3]]{
    {-2,0,-2},{-2,0,0},{-2,15,0},{-2,15,-2}
  }
  add_face(mesh,f0);
  add_face(mesh,f1);
  return mesh;
}

mesh_arch1 := arch1();
mesh_arch1_edge := arch1_edge();
mesh_col1_cap := col1_cap();
mesh_col1 := col1();
mesh_ceil1 := ceil1();
mesh_ceil1_corner := ceil1_corner();
mesh_arch2a := arch2(5.5);
mesh_arch2b := arch2(4.5);
mesh_arch2_edge := arch2_edge();
mesh_col2 := col2();
mesh_col3_cap := col3_cap();
mesh_col3 := col3();
mesh_arch3a := arch3a();
mesh_arch3b := arch3b();
mesh_arch3_edge1 := arch3_edge1();
mesh_arch3_edge2 := arch3_edge2();
mesh_arch3_ledge := arch3_ledge();
mesh_arch1_corner := arch1_corner();

func assembly1(pieces:list[Piece], trfm:vec[f32,4,4]){
  pieces.push(Piece{
    mesh: mesh_arch1,
    trfm: trfm @* rdr.mat.translate(10,14.5,20.)
  })
  pieces.push(Piece{
    mesh: mesh_arch1,
    trfm: trfm @* rdr.mat.translate(10,14.5,20.) @* rdr.mat.scale(-1.,1,1)
  })
  pieces.push(Piece{
    mesh: mesh_arch1_edge,
    trfm: trfm @* rdr.mat.translate(10,14.5,20.)
  })
  pieces.push(Piece{
    mesh: mesh_ceil1,
    trfm: trfm @* rdr.mat.translate(10,14.5,20.)
  })
  pieces.push(Piece{
    mesh: mesh_ceil1,
    trfm: trfm @* rdr.mat.translate(10,14.5,20.) @* rdr.mat.scale(-1.,1,1)
  })
  pieces.push(Piece{
    mesh: mesh_ceil1,
    trfm: trfm @* rdr.mat.translate(10,14.5,-1.5) @* rdr.mat.scale(1.,1,-1)
  })
  pieces.push(Piece{
    mesh: mesh_ceil1,
    trfm: trfm @* rdr.mat.translate(10,14.5,-1.5) @* rdr.mat.scale(-1.,1,-1)
  })
  pieces.push(Piece{
    mesh: mesh_col1_cap,
    trfm: trfm @* rdr.mat.translate(0.,14.5,20.)
  })
  pieces.push(Piece{
    mesh: mesh_col1_cap,
    trfm: trfm @* rdr.mat.translate(0.,14.5,-1.0)
  })
  pieces.push(Piece{
    mesh: mesh_col1,
    trfm: trfm @* rdr.mat.translate(0.,12.0,20.)
  })
  pieces.push(Piece{
    mesh: mesh_arch2b,
    trfm: trfm @* rdr.mat.translate(5.5,41.5,20.)
  })
  pieces.push(Piece{
    mesh: mesh_arch2a,
    trfm: trfm @* rdr.mat.translate(5.5,41.5,20.) @* rdr.mat.scale(-1.,1,1)
  })
  pieces.push(Piece{
    mesh: mesh_arch2a,
    trfm: trfm @* rdr.mat.translate(14.5,41.5,20.)
  })
  pieces.push(Piece{
    mesh: mesh_arch2b,
    trfm: trfm @* rdr.mat.translate(14.5,41.5,20.) @* rdr.mat.scale(-1.,1,1)
  })
  pieces.push(Piece{
    mesh: mesh_arch2_edge,
    trfm: trfm @* rdr.mat.translate(5.5,41.5,20.)
  })
  pieces.push(Piece{
    mesh: mesh_arch2_edge,
    trfm: trfm @* rdr.mat.translate(14.5,41.5,20.)
  })
  pieces.push(Piece{
    mesh: mesh_col2,
    trfm: trfm @* rdr.mat.translate(0.,41.5,20.)
  })
  pieces.push(Piece{
    mesh: mesh_col3_cap,
    trfm: trfm @* rdr.mat.translate(10.,41.5,20.)
  })
  pieces.push(Piece{
    mesh: mesh_col3,
    trfm: trfm @* rdr.mat.translate(10.,41,20.)
  })
  pieces.push(Piece{
    mesh: mesh_ceil1,
    trfm: trfm @* rdr.mat.translate(10,41,20.)
  })
  pieces.push(Piece{
    mesh: mesh_ceil1,
    trfm: trfm @* rdr.mat.translate(10,41,20.) @* rdr.mat.scale(-1.,1,1)
  })
  pieces.push(Piece{
    mesh: mesh_ceil1,
    trfm: trfm @* rdr.mat.translate(10,41,-1.5) @* rdr.mat.scale(1.,1,-1)
  })
  pieces.push(Piece{
    mesh: mesh_ceil1,
    trfm: trfm @* rdr.mat.translate(10,41,-1.5) @* rdr.mat.scale(-1.,1,-1)
  })
  pieces.push(Piece{
    mesh: mesh_col1_cap,
    trfm: trfm @* rdr.mat.translate(0.,41,-1.0)
  })
}

func assembly2(pieces:list[Piece], trfm:vec[f32,4,4]){
  pieces.push(Piece{
    mesh: mesh_ceil1_corner,
    trfm: trfm @* rdr.mat.translate(10,14.5,20.)
  })
  pieces.push(Piece{
    mesh: mesh_ceil1_corner,
    trfm: trfm @* rdr.mat.translate(8.5,14.5,20.) @* rdr.mat.scale(-1.,1,1)
  })
  pieces.push(Piece{
    mesh: mesh_ceil1_corner,
    trfm: trfm @* rdr.mat.translate(10,14.5,-1.5) @* rdr.mat.scale(1.,1,-1)
  })
  pieces.push(Piece{
    mesh: mesh_ceil1_corner,
    trfm: trfm @* rdr.mat.translate(8.5,14.5,-1.5) @* rdr.mat.scale(-1.,1,-1)
  })
  pieces.push(Piece{
    mesh: mesh_col1_cap,
    trfm: trfm @* rdr.mat.translate(-1.0,14.5,-1.0)
  })
  pieces.push(Piece{
    mesh: mesh_col1_cap,
    trfm: trfm @* rdr.mat.translate(-1.0,14.5,19.625)
  })
  pieces.push(Piece{
    mesh: mesh_arch1_corner,
    trfm: trfm @* rdr.mat.translate(20,14.5,20)
  })
}

func assembly3(pieces:list[Piece], trfm:vec[f32,4,4], end:i32){
  pieces.push(Piece{
    mesh: (end&2)?mesh_arch3b:mesh_arch3a,
    trfm: trfm @* rdr.mat.translate(10,0.,20.)
  })
  pieces.push(Piece{
    mesh: (end&1)?mesh_arch3b:mesh_arch3a,
    trfm: trfm @* rdr.mat.translate(10,0.,20.) @* rdr.mat.scale(-1.,1,1)
  })
  pieces.push(Piece{
    mesh: mesh_arch3_edge1,
    trfm: trfm @* rdr.mat.translate(10,0.,20.)
  })
  pieces.push(Piece{
    mesh: mesh_arch3_ledge,
    trfm: trfm @* rdr.mat.translate(10,0.,20.)
  })
  if (!(end&1)){
    pieces.push(Piece{
      mesh: mesh_arch3_edge2,
      trfm: trfm @* rdr.mat.translate(0,15.,20.)
    })
  }
}



func sponza(m:i32,n:i32):list[Piece]{
  pieces := list[Piece]{};
  wall1 := rdr.Mesh{};
  h := 77.5;
  add_face(wall1, list[vec[f32,3]]{
    {0.,h,0.0},
    {0.,0.,0.0},
    {(n+2)*20,0.,0.0},
    {(n+2)*20.,h,0.0},
  });
  wall2 := rdr.Mesh{};
  add_face(wall2, list[vec[f32,3]]{
    {0.,0.,0.0},
    {0.,h,0.0},
    {0,h,(m+2)*20},
    {0.,0.,(m+2)*20},
  });
  floor1 := rdr.Mesh{};
  add_face(floor1, list[vec[f32,3]]{
    {0.,0.,0.},
    {0.,0.,(m+2)*20},
    {(n+2)*20,0.,(m+2)*20},
    {(n+2)*20,0.,0.},
  });
  floor2a := rdr.Mesh{};
  add_face(floor2a, list[vec[f32,3]]{
    {0.,24.5,0.},
    {0.,24.5,20},
    {(n+2)*20,24.5,20},
    {(n+2)*20,24.5,0.},
  });
  floor2b := rdr.Mesh{};
  add_face(floor2b, list[vec[f32,3]]{
    {0.,24.5,20.},
    {0.,24.5,(m+1)*20},
    {20,24.5,(m+1)*20},
    {20,24.5,20.},
  });

  rot90 := rdr.mat.rotate_deg(rdr.AXIS_Y, 90);
  rot180 := rdr.mat.rotate_deg(rdr.AXIS_Y, 180);
  rot270 := rdr.mat.rotate_deg(rdr.AXIS_Y, 270);

  pieces.push(Piece{
    mesh: wall1,
    trfm: rdr.mat.translate(0.,0.,0.)
  })
  pieces.push(Piece{
    mesh: wall2,
    trfm: rdr.mat.translate(0.,0.,0.)
  })
  pieces.push(Piece{
    mesh: wall1,
    trfm: rdr.mat.translate(n*20+40,0.,m*20+40) @* rot180
  })
  pieces.push(Piece{
    mesh: wall2,
    trfm: rdr.mat.translate(n*20+40,0.,m*20+40) @* rot180
  })

  pieces.push(Piece{
    mesh: floor1,
    trfm: rdr.mat.id
  })
  pieces.push(Piece{
    mesh: floor2a,
    trfm: rdr.mat.id
  })
  pieces.push(Piece{
    mesh: floor2a,
    trfm: rdr.mat.translate(0,0.,m*20+20)
  })
  pieces.push(Piece{
    mesh: floor2b,
    trfm: rdr.mat.id
  })
  pieces.push(Piece{
    mesh: floor2b,
    trfm: rdr.mat.translate(n*20+20,0.,0)
  })

  pieces.push(Piece{
    mesh: floor2a,
    trfm: rdr.mat.translate(0,26.5,0)
  })
  pieces.push(Piece{
    mesh: floor2a,
    trfm: rdr.mat.translate(0,26.5,m*20+20)
  })
  pieces.push(Piece{
    mesh: floor2b,
    trfm: rdr.mat.translate(0,26.5,0)
  })
  pieces.push(Piece{
    mesh: floor2b,
    trfm: rdr.mat.translate(n*20+20,26.5,0)
  })

  pieces.push(Piece{
    mesh: roof1(m,n),
    trfm: rdr.mat.translate(0,h,0)
  })

  for (i := 0; i < n; i++){
    assembly1(pieces, rdr.mat.translate(20+i*20,0,0));
    assembly3(pieces, rdr.mat.translate(20+i*20,57.5,0), (i==0)|((i==n-1)<<1));
  }
  for (i := 0; i < m; i++){
    assembly1(pieces, rdr.mat.translate(0,0,m*20+20-i*20) @* rot90);
    assembly3(pieces, rdr.mat.translate(0,57.5,m*20+20-i*20) @* rot90, (i==0)|((i==m-1)<<1));
  }
  for (i := 0; i < n; i++){
    assembly1(pieces, rdr.mat.translate(n*20+20-i*20,0,m*20+40) @* rot180);
    assembly3(pieces, rdr.mat.translate(n*20+20-i*20,57.5,m*20+40) @* rot180, (i==0)|((i==n-1)<<1));
  }
  for (i := 0; i < m; i++){
    assembly1(pieces, rdr.mat.translate(n*20+40,0,i*20+20) @* rot270);
    assembly3(pieces, rdr.mat.translate(n*20+40,57.5,i*20+20) @* rot270,(i==0)|((i==m-1)<<1));
    
  }


  assembly2(pieces, rdr.mat.id);
  assembly2(pieces, rdr.mat.translate(0,0,m*20+40) @* rot90);
  assembly2(pieces, rdr.mat.translate(n*20+40,0,m*20+40) @* rot180);
  assembly2(pieces, rdr.mat.translate(n*20+40,0,0) @* rot270);

  assembly2(pieces, rdr.mat.translate(0,26.5,0));
  assembly2(pieces, rdr.mat.translate(0,26.5,m*20+40) @* rot90);
  assembly2(pieces, rdr.mat.translate(n*20+40,26.5,m*20+40) @* rot180);
  assembly2(pieces, rdr.mat.translate(n*20+40,26.5,0) @* rot270);

  return pieces;
}


normal_material := frag.program(embed (func(
  @builtin frag_coord:vec[f32,4],
  @varying normal:vec[f32,3],
  @varying position:vec[f32,3],
  @uniform view:vec[f32,4,4],
):vec[f32,4]{
  // c := normal*0.5+0.5;
  // return {c.x,c.y,c.z,1.0};
  
  c := normal.dot({0.1,0.2,0.3}.dir());
  c = c*0.4+0.6;
  // return {c,c,c,1.0};
  
  pw := {position.x, position.y, position.z, 1.0};
  pw = view @* pw;
  z := -pw.z/pw.w;
  z = 1.0-(z-10.0)/(120.0);
  // return {z,z,z,1.0};

  c *= z;
  return {c,c,c,1.0};

}) as "fragment");


cam := rdr.Camera{};
cam.perspective(60,W/(H as f32),0.1,1000.0);

eye := {0.,0,50};

yaw := -math.PI;
pitch := 0.;

vel := {0.,0.,0.};
spd := 0.05;
asp := 0.01;

keys_held := dict[i32,i32]{};
drag := {0.,0.,0.};

pieces := sponza(2,5);

while (1){
  
  time.fps(120);
  rdr.background(0.61,0.63,0.65);

  forward := ({
    math.cos(pitch)*math.sin(yaw),
    math.sin(pitch),
    math.cos(pitch)*math.cos(yaw)
  }).dir();
  right := forward.cross({0.,1.,0.});
  up := right.cross(forward);

  cam.look_at(eye,eye+forward,rdr.AXIS_Y);

  frag.begin(normal_material);
  cam.begin();
  for (i := 0; i < pieces.length(); i++){
    pieces[i].mesh.draw(pieces[i].trfm);
  }
  cam.end();
  frag.end();


  if (keys_held['w']){
    vel += forward*spd;
  }
  if (keys_held['s']){
    vel -= forward*spd;
  }
  if (keys_held['a']){
    vel -= right*spd;
  }
  if (keys_held['d']){
    vel += right*spd;
  }
  vel *= 0.9;
  eye += vel;

  e := win.poll();
  if (e.type == win.KEY_PRESSED){
    keys_held[e.key] = 1;
  }else if (e.type == win.KEY_RELEASED){
    keys_held[e.key] = 0;
  }else if (e.type == win.MOUSE_PRESSED){
    drag = {e.x,e.y,1.0};
    
  }else if (e.type == win.MOUSE_RELEASED){
    drag = {e.x,e.y,0.0};
  }else if (e.type == win.MOUSE_MOVED){
    if (drag.z){
      dx := drag.x - e.x;
      dy := drag.y - e.y;
      
      yaw -= dx*asp;
      pitch -= dy*asp;
      pitch = math.min(math.max(pitch,-math.PI/2+0.01),math.PI/2-0.01);
      drag = {e.x,e.y,1.0};
    }
  }
  
}