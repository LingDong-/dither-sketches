include "std/rdr"
include "std/math"
include "std/io"
include "std/frag"
include "std/list"
include "std/vec"
include "std/win"
include "std/rand"
include "std/time"
include "std/img"
include "std/geom"

func generate_mesh(w:f32,h:f32,d:f32):rdr.Mesh{
  func sgn(x:f32):f32{
    if (x > 0.0) return 1.0;
    if (x < 0.0) return -1.0;
    return 0.0;
  }
  mesh := rdr.Mesh{};
  n := 50;
  m := 80;
  cor := 0.15;
  la := list[vec[f32,2]]{};
  lb := list[vec[f32,2]]{};
  for (j := 0; j < m; j++){
    s := (j as f32)/(m-1);
    a := s*math.PI*2+math.PI;
    sina := math.sin(a);
    cosa := math.cos(a);
    x := sgn(cosa)*math.abs(cosa)**cor*w;
    z := sgn(sina)*math.abs(sina)**cor*d;
    la.push({x,z});
  }
  la[la.length()-1] = la[0]
  for (i := 0; i < n; i++){
    t := (i as f32)/(n-1);
    b := t*math.PI;
    sinb := math.sin(b);
    cosb := math.cos(b);
    r := sgn(sinb)*math.abs(sinb)**cor;
    y := sgn(cosb)*math.abs(cosb)**cor;
    lb.push({r,y});
  }
  lb[lb.length()-1] = {0.0,-1.0};
  la = geom.poly_resample(la, m, geom.MODE_POLYLINE|geom.BY_COUNT);
  lb = geom.poly_resample(lb, n, geom.MODE_POLYLINE|geom.BY_COUNT);

  for (i := 0; i < n; i++){
    for (j := 0; j < m; j++){
      t := 1.0-(lb[i].y*0.5+0.5);

      r := lb[i].x*0.5;
      x := r*la[j].x;
      y := lb[i].y*0.5*h;
      z := r*la[j].y;

      q := 1.0;
      q = rand.noise(x+w,y*2.0+h,z+d)*0.1+0.9;
      if (t < 0.1){
        q *= 0.95;
      }else if (t < 0.5){
        q *= math.sin((t-0.1)/0.4*math.PI)*0.1+0.9;
      }else{
        q *= q;
      }
      mesh.vertices.push({x*q,y,z*q});
      mesh.uvs.push({
        (j as f32)/(m-1),
        (i as f32)/(n-1)
      });
    }
  }
  for (i := 0; i < n; i++){
    if (i == 0){
      for (j := 0; j < m; j++) mesh.normals.push({0,1.,0})
      continue;
    }
    if (i == n-1){
      for (j := 0; j < m; j++) mesh.normals.push({0,-1.,0})
      continue;
    }
    for (j := 0; j < m; j++){
      a := mesh.vertices[i*m+j];
      b := mesh.vertices[i*m+(j+1)%m];
      c := mesh.vertices[(i+1)*m+j];
      d := mesh.vertices[i*m+(j-1+m)%m];
      e := mesh.vertices[(i-1)*m+j];
      nml := ((c-a).cross(b-a).dir() + 
              (d-a).cross(c-a).dir() + 
              (e-a).cross(d-a).dir() + 
              (b-a).cross(e-a).dir()
      ).dir()*-1;
      mesh.normals.push(nml);
    }
  }
  for (i:=0; i<n-1; i++){
    for (j:=0; j<m-1; j++){
      mesh.indices.push(i*m+j);
      mesh.indices.push((i+1)*m+(j+1)%m);
      mesh.indices.push(i*m+(j+1)%m);
      mesh.indices.push(i*m+j);
      mesh.indices.push((i+1)*m+(j+1)%m);
      mesh.indices.push((i+1)*m+j);
    }
  }
  // mesh.mode = rdr.MODE_POINT_LIST;
  return mesh;
}

func update_mesh(mesh:rdr.Mesh,t_verts:list[vec[f32,3]],t_norms:list[vec[f32,3]],w:f32,r:f32){
  th := w/r;
  for (i := 0; i < mesh.vertices.length(); i++){
    t := (t_verts[i].x + w*0.5)/w;
    b := -(t-0.5)*th;
    a := math.PI/2+b;
    mesh.vertices[i] = {
      math.cos(a)*(r+t_verts[i].y),
      math.sin(a)*(r+t_verts[i].y)-r,
      t_verts[i].z
    }
    costh := math.cos(b);
    sinth := math.sin(b);
    mesh.normals[i] = {
      t_norms[i].x*costh-t_norms[i].y*sinth,
      t_norms[i].x*sinth+t_norms[i].y*costh,
      t_norms[i].z
    }
  }
}

dims := {5.0,4.0,3.0};
mesh := generate_mesh(...dims);

t_verts := mesh.vertices.slice();
t_norms := mesh.normals.slice();

W := 640
H := 480
context := win.init(W,H,win.CONTEXT_3D)
rdr.init(context);
frag.init(context);

func sigmoid(x:f32,a:f32):f32{
  x = math.min(math.max(x,0.0),1.0);
  a = 1.0-a;
  y := 0.0;
  if (x<=0.5){
    y = ((2.0*x)**(1.0/a))/2.0;
  } else {
    y = 1.0 - ((2.0*(1.0-x))**(1.0/a))/2.0;
  }
  return y;
}

normal_material := frag.program(embed (func(
  @varying normal:vec[f32,3],
  @varying uv:vec[f32,2],
):vec[f32,4]{
  c := normal*0.5+0.5;
  // return {c.x,c.y,c.z,1.0};
  return {uv.x,uv.y,1.0,1.0};
}) as "fragment");

tex_bump := frag.texture(512,512,frag.FILTER_MIPMAP|frag.WRAP_REPEAT);
frag.begin(frag.program(embed (func(
  @builtin frag_coord:vec[f32,4],
  @varying normal:vec[f32,3],
  @varying uv:vec[f32,2],
  @uniform view:vec[f32,4,4],
):vec[f32,4]{
  // r := math.sin(uv.y*math.PI)+0.05;
  r := math.sqrt(1-(uv.y*2.0-1.0)**2.0)+0.05;
  x := math.cos(uv.x*math.PI*2)*r+1.1;
  y := math.sin(uv.x*math.PI*2)*r+1.3;
  q := rand.noise(x*5.0,y*5.0,uv.y*40.0-10.0);
  if (uv.y < 0.28){
    q = sigmoid(q+0.4,0.8)*0.5;
  }else if (uv.y < 0.32){
    t := (uv.y - 0.28)/0.04;
    q = sigmoid(q+0.4-t*0.2,0.8-t*0.2)*(0.5-t*0.3)+(t*0.3);
  }else if (uv.y < 0.48){
    q = sigmoid(q+0.2,0.6)*0.2+0.3;
  }else if (uv.y < 0.52){
    t := (uv.y - 0.48)/0.04;
    q = sigmoid(q+0.2-t*0.2,0.6-t*0.6)*(0.2+t*0.8)+0.3-t*0.3;
  }
  return {q,q,q,1.0};
}) as "fragment"), tex_bump);
frag.render();
frag.end();

tex_diff := frag.texture(512,512,frag.FILTER_MIPMAP|frag.WRAP_REPEAT);
frag.begin(frag.program(embed (func(
  @builtin frag_coord:vec[f32,4],
  @varying normal:vec[f32,3],
  @varying uv:vec[f32,2],
  @uniform view:vec[f32,4,4],
):vec[f32,4]{
  r := math.sqrt(1-(uv.y*2.0-1.0)**2.0)+0.05;
  x := math.cos(uv.x*math.PI*2)*r+1.1;
  y := math.sin(uv.x*math.PI*2)*r+1.3;
  q := rand.noise(x*10.0,y*10.0,uv.y*40.0-10.0);
  q = sigmoid(q+0.2,0.5);
  c0 := {0.4,0.2,0.1};
  c1 := {0.25,0.1,0.1};
  c2 := {0.5,0.2,0.0};
  c3 := {0.4,0.1,0.1};
  c4 := {0.5,0.2,0.1};
  c5 := {0.7,0.4,0.2};
  tilt := math.sin(uv.x*math.PI)*0.05;
  if (uv.y < 0.28){
    c0 = c2;
    c1 = c3;
  }else if (uv.y < 0.32){
    t := (uv.y - 0.28)/0.04;
    c0 = c2 * (1-t) + c4 * t;
    c1 = c3 * (1-t) + c5 * t;
  }else if (uv.y < 0.48){
    c0 = c4;
    c1 = c5;
  }else if (uv.y < 0.52){
    t := (uv.y - 0.48)/0.04;
    c0 = c4 * (1-t) + c0 * t;
    c1 = c5 * (1-t) + c1 * t;
  }else if (uv.y < 0.56){

  }else if (uv.y < 0.6){
    t := (uv.y - 0.56)/0.04;
    c0 = c0 * (1-t) + c4 * t;
    c1 = c1 * (1-t) + c5 * t;
  }else if (uv.y < 0.61+tilt){
    t := (uv.y - 0.6)/(0.01+tilt);
    c0 = c4 * (1-t) + c0 * t;
    c1 = c5 * (1-t) + c1 * t;
  }
  c := c0 * (1-q) + c1 * q;
  return {...c,1.0};
}) as "fragment"), tex_diff);
frag.render();
frag.end();

// io.write_file("test.png",img.encode("png",tex_bump.read_pixels()))

func compute_tbn(
  Ng : vec[f32,3],
  dpdx:vec[f32,3],dpdy:vec[f32,3],
  dtdx:vec[f32,2],dtdy:vec[f32,2],
):vec[f32,3,3]{
  det := dtdx.x*dtdy.y - dtdy.x*dtdx.y;
  T := dpdx * (dtdy.y/det) + dpdy * (-dtdx.y/det);
  B := dpdx * (-dtdy.x/det) + dpdy * (dtdx.x/det);
  T = (T - Ng * Ng.dot(T)).dir();
  B = (B - Ng * Ng.dot(B)).dir();
  N := T.cross(B).dir();
  if (N.dot(Ng)<0.0){
    N *= -1.;
  }
  return {
    T.x, T.y, T.z;
    B.x, B.y, B.z;
    N.x, N.y, N.z;
  }
}
func gradient(
  htex:frag.Texture, uv:vec[f32,2], texel:vec[f32,2]
):vec[f32,2]{
  h  := htex.sample(uv).r;
  hU := htex.sample({(uv.x+texel.x),uv.y}).r;
  hV := htex.sample({uv.x,(uv.y+texel.y)}).r;
  dhu := (hU - h) / texel.x;
  dhv := (hV - h) / texel.y;
  return {dhu,dhv};
}

func perturb(tbn:vec[f32,3,3], dhuv:vec[f32,2], scale:f32):vec[f32,3]{
  T := {tbn[0,0],tbn[0,1],tbn[0,2]};
  B := {tbn[1,0],tbn[1,1],tbn[1,2]};
  N := {tbn[2,0],tbn[2,1],tbn[2,2]};
  return (N - scale * (dhuv.x * T + dhuv.y * B)).dir();
}

phong_material := frag.program(embed (func(
  @varying normal : vec[f32,3],
  @varying position : vec[f32,3],
  @uniform eye : vec[f32,3],
  @uniform l_dir : vec[f32,3],
  @varying uv:vec[f32,2],
  @uniform map_bump: frag.Texture,
  @uniform map_diff: frag.Texture,
  @builtin frag_coord : vec[f32,4],
  @derived d_position_dx : vec[f32,3],
  @derived d_position_dy : vec[f32,3],
  @derived d_uv_dx : vec[f32,2],
  @derived d_uv_dy : vec[f32,2],
  @uniform col_spec : vec[f32,3],
  @uniform col_ambi : vec[f32,3],
  @uniform shininess : f32,
  @uniform bumpiness : f32,
):vec[f32,4]{

  texel := {0.001,0.001};
  dhuv := gradient(map_bump,uv,texel);
  tbn := compute_tbn(
    normal,
    d_position_dx,d_position_dy,
    d_uv_dx,d_uv_dy
  );
  nml := perturb(tbn,dhuv,bumpiness);

  view_dir := eye - position;
  half_vec := (l_dir + view_dir).dir();
  ndl := math.max(nml.dot(l_dir),0.0);
  ndh := math.max(nml.dot(half_vec),0.0);

  col := map_diff.sample(uv).xyz;
  diff := col * ndl;
  ambi := col * col_ambi;
  spec := col_spec * (ndh ** shininess);
  color := diff+ambi+spec;

  return {...color,1.0};
}) as "fragment")



cam := rdr.Camera{};
cam.perspective(60,W/(H as f32),0.01,100.0);

hud := rdr.Camera{};
hud.ortho(0,W,H,0,-1,1);

yaw := math.PI/6;
pitch := math.PI/12;
zoom := 8.0;
drag := {0.,0.,0.};
targ := {0.,0.,0.};
keys_held := dict[i32,i32]{};

l_dir := {1.0,2.0,3.0}.dir();

while (1){
  time.fps(120);
  rdr.background(0.9,0.8,0.7);

  eye := {
    math.cos(pitch)*math.sin(yaw),
    math.sin(pitch),
    math.cos(pitch)*math.cos(yaw)
  }*zoom;
  horz := eye.cross({0,1.,0}).dir();
  vert := eye.cross(horz).dir();
  cam.look_at(eye+targ,targ,rdr.AXIS_Y);

  rad := math.sin(time.millis()*0.01)*4.0+12.0;
  update_mesh(mesh,t_verts,t_norms,dims.x,rad);

  // frag.begin(normal_material);
  frag.begin(phong_material);
  frag.uniform("l_dir",l_dir);
  frag.uniform("eye",eye+targ);
  frag.uniform("map_bump",tex_bump);
  frag.uniform("map_diff",tex_diff);
  frag.uniform("shininess",48.0);
  frag.uniform("bumpiness",0.02);
  frag.uniform("col_ambi",{0.3,0.3,0.3});
  frag.uniform("col_spec",{0.7,0.6,0.5});
  cam.begin();
  mesh.draw(rdr.mat.id);
  cam.end();
  frag.end();

  mesh.update(rdr.DIRTY_VERTICES|rdr.DIRTY_NORMALS);

  hud.begin();
  rdr.text(" BRAISED PORK:       [LMB-DRAG] ROTATE  [RMB-DRAG/SHIFT-DRAG] PAN  [WHEEL] ZOOM ",rdr.mat.translate(0,H-16,0));
  hud.end();


  e := win.poll();
  if (e.type == win.MOUSE_PRESSED){
    drag = {e.x,e.y,(e.key==win.MOUSE_RIGHT || keys_held[win.KEY_LSHIFT as i32])?-1.0:1.0};
  }else if (e.type == win.MOUSE_RELEASED){
    drag = {e.x,e.y,0.0};
  }else if (e.type == win.MOUSE_MOVED){
    if (drag.z){
      dx := drag.x - e.x;
      dy := drag.y - e.y;
      if (drag.z > 0){
        yaw -= dx*0.01;
        pitch -= dy*0.01;
        pitch = math.min(math.max(pitch,-math.PI/2+0.01),math.PI/2-0.01);
      }else{
        targ -= horz * dx*0.005*zoom - vert * dy*0.005*zoom;
      }
      drag = {e.x,e.y,drag.z};
    }
  }else if (e.type == win.WHEEL_SCROLLED){
    zoom += e.y*0.01;
    if (zoom < 0.1){
      zoom = 0.1;
    }else if (zoom > 100.0){
      zoom = 100.0;
    }
  }else if (e.type == win.KEY_PRESSED){
    keys_held[e.key] = 1;
  }else if (e.type == win.KEY_RELEASED){
    keys_held[e.key] = 0;
  }
}

