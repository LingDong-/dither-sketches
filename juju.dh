include "std/math"
include "std/list"
include "std/g3d"
include "std/frag"
include "std/win"
include "std/time"
include "std/img"
include "std/io"
include "std/arr"
include "std/rand"
include "std/vec"


func jujube(m:i32,n:i32):g3d.Mesh{
  vertices:=list[vec[f32,3]]{ };
  indices:=list[i32]{};
  normals:=list[vec[f32,3]]{ };
  uvs:=list[vec[f32,2]]{};

  for (i := 0; i < m; i++){
    th := i*math.PI/(m-1);
    sinth := math.sin(th);
    costh := math.cos(th);
    sth := (sinth+1)*sinth*(0.5+0.1*th);
    cth := (sinth+1)*costh;
    snm := -(math.cos(2*th)-sinth);
    cnm := costh*(0.5+0.1*th)*(2*sinth+1)+0.1*(sinth+1)*sinth;
    for (j := 0; j < n; j++){
      ph := j*math.PI*2./(n-1);
      cosph := math.cos(ph);
      sinph := math.sin(ph);
      x := sth*cosph;
      z := sth*sinph;
      y := cth;
      nx := snm*cosph;
      nz := snm*sinph;
      ny := cnm;
      vertices.push({x,y,z});
      normals.push({nx,ny,nz});
      uvs.push({(j as f32)/(n-1),(i as f32)/(m-1)});

      if (i && j){
        indices.push(i*n+j);
        indices.push((i-1)*n+(j-1));
        indices.push(i*n+(j-1));
        indices.push(i*n+j);
        indices.push((i-1)*n+j);
        indices.push((i-1)*n+(j-1))
      }
    }
  }
  return g3d.Mesh{
    vertices:vertices,indices:indices,normals:normals,uvs:uvs
  };
  
}


func sigmoid(x:f32,k:f32):f32{
  return 1./(1.+math.exp(-k*(x-0.5)));
}

W := 256
H := 256
context := win.init(W,H,win.CONTEXT_3D);
g3d.init(context);
frag.init(context);

pixels := arr.make({H,W,4},0 as u8);
for (i:=0;i<H;i++){
  for (j:=0;j<W;j++){
    t := j*2.0*math.PI/W;
    v := rand.noise(i*0.02,10.0+math.cos(t),3+math.sin(t));
    v = sigmoid(v,20);
    c := math.lerp({0.5,0.2,0.1},{0.8,1.0,0.4},v)
    c = math.lerp({0.1,0,0},c,math.sin(i*math.PI/H));
    pixels[i,j,0] = c.x*255;
    pixels[i,j,1] = c.y*255;
    pixels[i,j,2] = c.z*255;
    pixels[i,j,3] = 255;
  }
}

image := frag.texture(...pixels.shape().yx);
image.write_pixels(pixels);


shader0 := frag.program(embed(func(
  @varying normal:vec[f32,3],
  @varying uv:vec[f32,2],
  @uniform image:frag.Texture,
  @varying position:vec[f32,3],
  @uniform l:vec[f32,3], 
  @uniform eye:vec[f32,3],
  @uniform spec:vec[f32,3],
  @uniform shininess:f32,  
  ):vec[f32,4]{
    
  base := image.sample(uv).xyz;
    
  view_dir := eye - position;
  half_vec := (l + view_dir).dir();

  ndl := math.max(normal.dot(l),0.0);
  ndh := math.max(normal.dot(half_vec),0.0);

  df := base * (ndl*0.9+0.1);
  hl := spec * (ndh ** shininess);

  c := df + hl;
  
  return {c.x,c.y,c.z,1.0};
}) as "fragment");

meshes := list[g3d.Mesh]{
  jujube(24,24)
};

cam := g3d.Camera{}
cam.perspective(45,W/(H as f32),0.1,100.0);
eye := {0.,0,5};
cam.look_at(eye,{0,0,0},g3d.AXIS_Y);

frame := 0;
while (1){
  time.fps(60);
  g3d.background(0.)

  frag.begin(shader0);
  frag.uniform("image",image);
  frag.uniform("l",({0.1,0.2,0.3}).dir());
  frag.uniform("eye",eye);
  frag.uniform("shininess",32.0);
  frag.uniform("spec",{0.4,0.4,0.2});
  
  cam.begin();
  for (i := 0; i < meshes.length(); i++){
    model :=g3d.mat.rotate_deg(g3d.AXIS_X,frame)@*g3d.mat.rotate_deg(g3d.AXIS_Y,frame)
    meshes[i].draw(model)
  }
  cam.end();
  frag.end();
  
  g3d.flush();
  win.poll();
  frame++;
}