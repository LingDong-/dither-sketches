include "std/g3d"
include "std/win"
include "std/rand"
include "std/math"
include "std/list"
include "std/frag"
include "std/vec"
include "std/io"
include "std/time"
include "std/arr"
include "std/guts"

W := 1280
H := 720

hmw := 600;
hmh := 750;

cmw := 150;
cmh := 100;
cmH := 180;

nbirds := 50;

c2h := hmw/cmw;

hmr := 0.64;
light := {0.6, 0.0, 0.0}
sky := 0.65;

context := win.init(W,H,win.CONTEXT_3D);
g3d.init(context);
frag.init(context);

sd := 1753458005;//time.stamp();
io.println("seed: %{sd}");
rand.seed(sd);

func foggy_material(
  @varying normal:vec[f32,3],
  @varying color:vec[f32,4],
  @varying position:vec[f32,3],
):vec[f32,4]{
  // z := -position.z;
  z := position.mag();
  t := math.min(math.max((z-100.0)/280.0,0.0),1.0);
  c := color.x * (1.-t) + sky * t;
  return {c,c,c,color.w};
}
shader0 := frag.program(embed foggy_material as "fragment");

terrain := g3d.Mesh{};
branches := g3d.Mesh{mode:g3d.MODE_LINE_LIST};
leaves := g3d.Mesh{}
cloudmap := arr.make({hmh,hmw},0.0);
clouds := g3d.Mesh{}
birds := g3d.Mesh{mode:g3d.MODE_LINE_LIST}

func sigmoid(x:f32,k:f32):f32{
  return 1./(1.+math.exp(-k*(x-0.5)));
}

func draw_tree1(x:f32,y:f32,z:f32,a:f32,aa:f32,d:f32,n:i32){
  if (d < 0.2 || n <= 0) return;
  x0:=x+math.cos(a-aa)*d;
  y0:=y+math.sin(a-aa)*d;
  x1:=x+math.cos(a+aa)*d;
  y1:=y+math.sin(a+aa)*d;
  col:=rand.random(0.1);

  n := branches.vertices.length();
  branches.indices.push(n);
  branches.indices.push(n+1);
  branches.indices.push(n);
  branches.indices.push(n+2);
  branches.vertices.push({x,y,z});
  branches.vertices.push({x0,y0,z});
  branches.vertices.push({x1,y1,z});

  branches.colors.push({col,col,col,1.0});
  branches.colors.push({col,col,col,1.0});
  branches.colors.push({col,col,col,1.0});
  
  draw_tree1(x0,y0,z,a-aa,aa,d*(0.3+rand.random(0.7)),n-1);
  draw_tree1(x1,y1,z,a+aa,aa,d*(0.3+rand.random(0.7)),n-1);
}

func thick_line2d(p0:vec[f32,3],p1:vec[f32,3],w:f32,col:f32){
  d := (p1.xy-p0.xy).dir();
  e := {d.y*w,-d.x*w,0.0};
  n := leaves.vertices.length();
  leaves.vertices.push(p1 + e);
  leaves.vertices.push(p1 - e);
  leaves.vertices.push(p0 - e);
  leaves.vertices.push(p0 + e);
  leaves.indices.push(n);
  leaves.indices.push(n+1);
  leaves.indices.push(n+2);
  leaves.indices.push(n);
  leaves.indices.push(n+2);
  leaves.indices.push(n+3);
  for (i:=0; i<4; i++){
    leaves.colors.push({col,col,col,1.0});
  }
}

func draw_tree2(x:f32,y:f32,z:f32){

  thick_line2d({x,y,z},{x,y+5,z},0.2,0.0);

  for (i := 0; i < 12; i++){
    h := 6.0;
    dx := 0;
    if (i != 0){
      h = rand.random(1.0,6.0);
      dx = rand.random(-2.5,2.5);
    }
    w0 := rand.random(2.5);
    w1 := rand.random(2.5);

    thick_line2d({x,y+h-2,z},{x+dx,y+h-0.8,z},0.12,0.0);

    g := rand.random(0.05);
    n := leaves.vertices.length();

    leaves.indices.push(n);
    leaves.indices.push(n+1);
    leaves.indices.push(n+2);
    leaves.vertices.push({x+dx,y+h,z});
    leaves.vertices.push({x+dx-w1,y+h-0.8,z});
    leaves.vertices.push({x+dx+w0,y+h-0.8,z});
    leaves.colors.push({g,g,g,1});
    leaves.colors.push({g,g,g,1});
    leaves.colors.push({g,g,g,1});
  }
}

func draw_tree3(x:f32,y:f32,z:f32){
  n := leaves.vertices.length();
  leaves.indices.push(n);
  leaves.indices.push(n+1);
  leaves.indices.push(n+2);
  leaves.vertices.push({x,y,z});
  leaves.vertices.push({x+1.5,y+1.5,z});
  leaves.vertices.push({x-1.5,y+1.5,z});
  leaves.colors.push({0.0,0,0,1});
  leaves.colors.push({0.0,0,0,1});
  leaves.colors.push({0.0,0,0,1});
}

io.println("generating terrain...");

for (i:=0; i<hmh; i++){
  for (j:=0; j<hmw; j++){
    ns0 := rand.noise(i*0.01,j*0.01,0);
    ns1 := rand.noise(i*0.04, j*0.04,1);
    ns2 := rand.noise(i*0.01,j*0.01,2);
    g0 := sigmoid(ns0*0.5 + ns1*0.5,20);
    g := g0*g0*ns2;
    terrain.vertices.push({
      (-hmw/2+j)*hmr, g*120, -i*hmr
    });
    terrain.normals.push({0.,1,0});
    terrain.colors.push({0.,0,0,1});

    cloudmap[i,j] = rand.noise(i*0.02,j*0.02,99)*math.min(1.,math.sin((j as f32)/hmw*math.PI)*3.);

    if (i && j){
      terrain.indices.push((i-1)*hmw+(j-1));
      terrain.indices.push(i*hmw+j);
      terrain.indices.push((i-1)*hmw+j);
      
      terrain.indices.push((i-1)*hmw+(j-1));
      terrain.indices.push(i*hmw+(j-1));
      terrain.indices.push(i*hmw+j);

    }
  }
}

io.println("generating clouds...");

for (i:=0; i<cmh; i++){
  for (j:=0; j<cmw; j++){
    clouds.vertices.push({
      (-cmw/2+j)*hmr*c2h, 20, -i*hmr*c2h
    });
    clouds.colors.push({1.0,1.0,1.0,1.0});
    if (i && j){
      clouds.indices.push((i-1)*cmw+(j-1));
      clouds.indices.push(i*cmw+j);
      clouds.indices.push((i-1)*cmw+j);
      clouds.indices.push((i-1)*cmw+(j-1));
      clouds.indices.push(i*cmw+(j-1));
      clouds.indices.push(i*cmw+j);
    }
  }
}
for (i:=0; i<cmH; i++){
  for (j:=0; j<cmw; j++){
    clouds.vertices.push({
      (-cmw/2+j)*hmr*c2h, 60, -i*hmr*c2h
    });
    clouds.colors.push({1.0,1.0,1.0,1.0});
    if (i && j){
      base := cmw*cmh;
      clouds.indices.push(base+(i-1)*cmw+(j-1));
      clouds.indices.push(base+i*cmw+j);
      clouds.indices.push(base+(i-1)*cmw+j);
      clouds.indices.push(base+(i-1)*cmw+(j-1));
      clouds.indices.push(base+i*cmw+(j-1));
      clouds.indices.push(base+i*cmw+j);
    }
  }
}
clouds.update(0xff);

io.println("generating lighting and vegetation...");

for (i:=1; i<hmh-1; i++){
  for (j:=1; j<hmw-1; j++){
    o := terrain.vertices[i*hmw+j];
    a := terrain.vertices[i*hmw+j-1]-o;
    b := terrain.vertices[i*hmw+j+1]-o;
    c := terrain.vertices[(i-1)*hmw+j]-o;
    d := terrain.vertices[(i+1)*hmw+j]-o;
    bc := c.cross(b).dir();
    ca := a.cross(c).dir();
    ad := d.cross(a).dir();
    db := b.cross(d).dir();
    nml := (bc+ca+ad+db)*0.25;
    terrain.normals[i*hmw+j] = nml;
    ndl := math.max(0.,math.min(1.,nml.dot(light)))
    clr := o.y*0.002-0.02+0.05*ndl-0.02*rand.random(0.02);
    terrain.colors[i*hmw+j] = {clr,clr,clr,1.0};

    if (nml.z > -0.4 && 
      o.y > rand.random(30.) + rand.noise(i*0.2,j*0.2,13)*80 && 
      rand.random(100.) > 10. &&
      i > 25){

      if (rand.noise(i*0.2,j*0.2,42) > 0.5 || i < 50 || o.y<40){
        if (i < 250){
          draw_tree1(...o,math.PI/2,
            rand.random(0.28,0.78),math.max(1.0,4-o.y*0.05),
          6);
        }else{
          draw_tree3(...o);
        }
      }else{
        if (i < 250){
          draw_tree2(...o);
        }else{
          draw_tree3(...o);
        }
      }
    }
  }
}

io.println("generating birds...");

for (i:=0; i<nbirds; i++){
  birds.vertices.push({
    rand.random(-50.0,50.0),
    rand.random(40.0,100.0),
    rand.random(-500.0,0.0),
  });
  birds.colors.push({0.,0,0,1});
  for (j:=0; j<5; j++){
    birds.vertices.push({0.,0,0});
    birds.colors.push({0.,0,0,1});
  }
  birds.indices.push(i*6+1);
  birds.indices.push(i*6+2);
  birds.indices.push(i*6+1);
  birds.indices.push(i*6+3);
  birds.indices.push(i*6+4);
  birds.indices.push(i*6+5);
}
birds.update(0xff);

io.println("rendering...");

framecnt := 0

while (1){
  time.fps(60);

  cam := g3d.Camera{};
  cam.perspective(60, (W as f32)/H, 1, 512);
  cam.view = g3d.mat.translate(-math.sin(framecnt*0.002)*10,-80,-5) @* 
             g3d.mat.rotate_deg(g3d.AXIS_X, 22);

  dx := c2h
  for (i:=0; i<cmh; i++){
    for (j:=0; j<cmw; j++){
      i0 := i*dx;
      j0 := j*dx;
      jj := (j0+framecnt/2)%(hmw-dx);
      col0 := 0.8*(-0.3-terrain.vertices[i0*hmw+j0].y*0.05+cloudmap[i0,jj]);
      ii := (i0+4)%(hmh-dx);
      h0 := 5.0+cloudmap[ii,jj]*20.0;
      v := clouds.vertices[i*cmw+j];
      clouds.vertices[i*cmw+j] = {v.x,h0,v.z};
      clouds.colors[i*cmw+j] = {1.0,1.0,1.0,col0};
    }
  }
  for (i:=0; i<cmH; i++){
    for (j:=0; j<cmw; j++){
      i0 := i*dx;
      j0 := j*dx;
      jj := (j0+framecnt/2+19)%(hmw-dx);
      col0 := -0.4+(-terrain.vertices[i0*hmw+j0].y*0.05+cloudmap[i0,jj]);
      ii := (i0+49)%(hmh-dx);
      h0 := 50.0+cloudmap[ii,jj]*10.0;
      v := clouds.vertices[cmw*cmh+i*cmw+j];
      clouds.vertices[cmw*cmh+i*cmw+j] = {v.x,h0,v.z};
      clouds.colors[cmw*cmh+i*cmw+j] = {1.0,1.0,1.0,col0};
    }
  }
  clouds.update(g3d.DIRTY_VERTICES | g3d.DIRTY_COLORS);

  for (i:=0; i<nbirds; i++){
    r := birds.vertices[i*6];
    l := math.sin(framecnt*0.1+i*0.1);

    birds.vertices[i*6+1] = {r.x,r.y-l,r.z};
    birds.vertices[i*6+2] = {r.x-1,r.y,r.z};
    birds.vertices[i*6+3] = {r.x+1,r.y,r.z};
    birds.vertices[i*6+4] = {r.x,r.y-l,r.z-0.3};
    birds.vertices[i*6+5] = {r.x,r.y-l,r.z+0.3};

    birds.vertices[i*6] = r + {0.,0,0.4};
    if (r.z > hmh*hmr*0.5){
      birds.vertices[i*6] = {r.x,r.y,-hmh*hmr};
    }
  }
  birds.update(g3d.DIRTY_VERTICES);

  g3d.background(sky);

  frag.begin(shader0);
  cam.begin();
  terrain.draw(g3d.mat.id);
  branches.draw(g3d.mat.id);
  leaves.draw(g3d.mat.id);
  clouds.draw(g3d.mat.id);
  birds.draw(g3d.mat.id);
  cam.end()
  frag.end();

  win.poll();
  framecnt++;
}

